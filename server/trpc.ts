import { initTRPC } from '@trpc/server';
import { z } from 'zod';
import type { UserDO } from './UserDO';
import type { Entry } from './UserDO';
import type { WorkflowParams } from './SignalsWorkflow';
import type { FeedWorkflowParams } from './FeedWorkflow';
import type { TimelineData } from './services';

export interface Context {
    userId: string;
    userDO: DurableObjectStub<UserDO>;
    signalsWorkflow?: Workflow<WorkflowParams>;
    feedWorkflow?: Workflow<FeedWorkflowParams>;
}

const t = initTRPC.context<Context>().create();

export const appRouter = t.router({
    entries: t.procedure
        .input(z.object({
            text: z.string(),
            source: z.string(),
        }))
        .mutation(async ({ ctx, input }) => {
            const entryId = await ctx.userDO.addEntry(ctx.userId, input.text, input.source);
            return { entry_id: entryId };
        }),

    home: t.procedure
        .query(async ({ ctx }) => {
            return await ctx.userDO.getHome(ctx.userId);
        }),

    // Note: addCommitment removed - commitments are now generated by LLM workflow

    // Legacy/Frontend Compatibility Router
    log: t.router({
        create: t.procedure
            .input(z.object({
                entryId: z.string(),
                text: z.string(),
                attachments: z.array(z.any()).optional(),
                rootId: z.string().optional(),
                parentId: z.string().optional(),
                followUp: z.any().optional(), // Provenance data
                event_type: z.enum(['task_start', 'task_snooze', 'task_skip', 'task_finish', 'commitment_acknowledge', 'commitment_complete', 'commitment_cancel', 'commitment_confirm', 'clarification_response']).optional(),
                linked_task_id: z.string().optional(),
                linked_commitment_id: z.string().optional(),
                event_payload: z.record(z.string(), z.any()).optional(),
                feed_item_id: z.string().nullable().optional(),
                action_type: z.string().nullable().optional(),
                action_context: z.record(z.string(), z.any()).optional(),
            }))
            .mutation(async ({ ctx, input }) => {
                // Map legacy input to addEntry options
                const entryId = await ctx.userDO.addEntry(ctx.userId, input.text, 'client_sync', {
                    id: input.entryId,
                    attachments: input.attachments,
                    rootId: input.rootId,
                    parentId: input.parentId,
                    linkedTaskId: input.linked_task_id,
                    linkedCommitmentId: input.linked_commitment_id,
                    eventType: input.event_type,
                    payload: input.event_payload,
                    feedItemId: input.feed_item_id,
                    actionType: input.action_type,
                    actionContext: input.action_context
                });

                // Return empty structure to satisfy legacy UI
                // If we want to restore follow-ups later, we can hook it here.
                return {
                    entry_id: entryId,
                    followUps: [],
                    analysis: null
                };
            }),

        getRecent: t.procedure
            .input(z.object({
                limit: z.number().optional().default(20),
            }))
            .query(async ({ ctx, input }) => {
                // Fetch raw entries
                const entries = await ctx.userDO.getRecentEntries(input.limit) as Entry[];

                // Map to snake_case for frontend
                return entries.map((e: Entry) => ({
                    entry_id: e.id,
                    created_at: e.created_at,
                    raw_text: e.text,
                    attachments_json: e.attachments_json, // Frontend parses this
                    root_id: e.root_id,
                    parent_id: e.parent_id,
                    // Metadata fields
                    event_type: e.event_type,
                    action_type: e.action_type,
                    action_context: e.action_context,
                    feed_item_id: e.feed_item_id,
                    linked_task_id: e.linked_task_id,
                    linked_commitment_id: e.linked_commitment_id,
                }));
            }),
    }),

    signals: t.router({
        list: t.procedure
            .input(z.object({
                entry_id: z.string().optional(),
                trigger_capture_id: z.string().optional(),
                include_history: z.boolean().optional().default(false),
                window_days: z.number().optional(),
            }))
            .query(async ({ ctx, input }) => {
                return await ctx.userDO.getSignals(ctx.userId, input);
            }),
    }),

    commitments: t.router({
        list: t.procedure
            .input(z.object({
                status: z.string().optional(),
                include_history: z.boolean().optional().default(false),
                trigger_capture_id: z.string().optional(),
            }))
            .query(async ({ ctx, input }) => {
                return await ctx.userDO.getCommitments(ctx.userId, input);
            }),
        getDetail: t.procedure
            .input(z.object({
                commitmentId: z.string(),
            }))
            .query(async ({ ctx, input }) => {
                // First try to find by ID in current commitments
                let commitments = await ctx.userDO.getCommitments(ctx.userId, {});
                let commitment = commitments.find(c => c.id === input.commitmentId);
                
                // If not found, try including history to find old versions
                if (!commitment) {
                    commitments = await ctx.userDO.getCommitments(ctx.userId, { include_history: true });
                    commitment = commitments.find(c => c.id === input.commitmentId);
                    
                    // If found in history, get the latest version of that commitment
                    if (commitment) {
                        const latestCommitments = await ctx.userDO.getCommitments(ctx.userId, {});
                        const latestCommitment = latestCommitments.find(
                            c => c.origin_entry_id === commitment!.origin_entry_id
                        );
                        if (latestCommitment) {
                            commitment = latestCommitment;
                        }
                    }
                }
                
                if (!commitment) {
                    throw new Error(`Commitment ${input.commitmentId} not found`);
                }
                return commitment;
            }),
    }),

    tasks: t.router({
        list: t.procedure
            .input(z.object({
                status: z.string().optional(),
                include_history: z.boolean().optional().default(false),
                trigger_capture_id: z.string().optional(),
            }))
            .query(async ({ ctx, input }) => {
                return await ctx.userDO.getTasks(ctx.userId, input);
            }),
        timeline: t.procedure
            .input(z.object({
                commitment_id: z.string().optional(),
                category: z.enum(['work', 'personal', 'health']).optional(),
                time_horizon: z.enum(['week', 'month', 'quarter']).optional(),
            }))
            .query(async ({ ctx, input }): Promise<TimelineData> => {
                return await ctx.userDO.getTimeline(ctx.userId, input);
            }),
    }),

    signalsGenerate: t.procedure
        .input(z.object({
            window_days: z.number().optional().default(30),
            trigger_capture_id: z.string().optional(),
        }))
        .mutation(async ({ ctx, input }) => {
            const recentEntries = await ctx.userDO.getRecentEntries(1) as Entry[];
            const triggerId = input.trigger_capture_id || recentEntries[0]?.id;
            if (!triggerId) {
                throw new Error('No capture found to trigger generation');
            }
            // Trigger workflow (optional - may not be available in all environments)
            if (ctx.signalsWorkflow) {
                await ctx.signalsWorkflow.create({
                    id: `${ctx.userId}-${triggerId}-${Date.now()}`,
                    params: {
                        userId: ctx.userId,
                        triggerCaptureId: triggerId,
                        windowDays: input.window_days || 30,
                    },
                });
            } else {
                console.warn('Signals workflow not available - skipping workflow trigger');
            }
            return { success: true };
        }),

    feed: t.router({
        getCurrent: t.procedure
            .query(async ({ ctx }) => {
                // Use direct RPC call instead of fetch()
                const feed = await ctx.userDO.getCurrentFeed(ctx.userId);
                // Ensure we always return an array
                return Array.isArray(feed) ? feed : [];
            }),
        refresh: t.procedure
            .mutation(async ({ ctx }) => {
                // Trigger feed regeneration manually via UserDO method
                // This ensures consistency with batch processing and clears regeneration flags
                await ctx.userDO.triggerFeedRegeneration(ctx.userId);
                return { success: true };
            }),
        getHistory: t.procedure
            .input(z.object({
                limit: z.number().optional().default(10),
            }))
            .query(async ({ ctx, input }) => {
                // Use direct RPC call instead of fetch()
                return await ctx.userDO.getFeedHistory(ctx.userId, input.limit);
            }),
    }),

    undo: t.router({
        revert: t.procedure
            .input(z.object({
                captureId: z.string(),
            }))
            .mutation(async ({ ctx, input }) => {
                await ctx.userDO.revertStateChange(ctx.userId, input.captureId);
                return { success: true };
            }),
    }),
});

export type AppRouter = typeof appRouter;
