import { initTRPC } from '@trpc/server';
import { z } from 'zod';
import type { UserTimelineDO } from './UserTimelineDO';
import type { UserSignalsDO } from './UserSignalsDO';
import type { UserCommitmentsDO } from './UserCommitmentsDO';
import type { UserTasksDO } from './UserTasksDO';
import type { UserFeedDO, FeedItemRendered } from './UserFeedDO';
import type { WorkflowParams } from './SignalsWorkflow';
import type { FeedWorkflowParams } from './FeedWorkflow';

export interface Context {
    userId: string;
    userTimeline: DurableObjectStub<UserTimelineDO>;
    userSignals: DurableObjectStub<UserSignalsDO>;
    userCommitments: DurableObjectStub<UserCommitmentsDO>;
    userTasks: DurableObjectStub<UserTasksDO>;
    userFeed: DurableObjectStub<UserFeedDO>;
    signalsWorkflow?: Workflow<WorkflowParams>;
    feedWorkflow?: Workflow<FeedWorkflowParams>;
}

const t = initTRPC.context<Context>().create();

export const appRouter = t.router({
    entries: t.procedure
        .input(z.object({
            text: z.string(),
            source: z.string(),
        }))
        .mutation(async ({ ctx, input }) => {
            const entryId = await ctx.userTimeline.addEntry(ctx.userId, input.text, input.source);
            return { entry_id: entryId };
        }),

    home: t.procedure
        .query(async ({ ctx }) => {
            return await ctx.userTimeline.getHome(ctx.userId);
        }),

    // Note: addCommitment removed - commitments are now generated by LLM workflow

    // Legacy/Frontend Compatibility Router
    log: t.router({
        create: t.procedure
            .input(z.object({
                entryId: z.string(),
                text: z.string(),
                attachments: z.array(z.any()).optional(),
                rootId: z.string().optional(),
                parentId: z.string().optional(),
                followUp: z.any().optional(), // Provenance data
            }))
            .mutation(async ({ ctx, input }) => {
                // Map legacy input to addEntry options
                const entryId = await ctx.userTimeline.addEntry(ctx.userId, input.text, 'client_sync', {
                    id: input.entryId,
                    attachments: input.attachments,
                    rootId: input.rootId,
                    parentId: input.parentId
                });

                // Return empty structure to satisfy legacy UI
                // If we want to restore follow-ups later, we can hook it here.
                return {
                    entry_id: entryId,
                    followUps: [],
                    analysis: null
                };
            }),

        getRecent: t.procedure
            .input(z.object({
                limit: z.number().optional().default(20),
            }))
            .query(async ({ ctx, input }) => {
                // Fetch raw entries
                const entries = await ctx.userTimeline.getRecentEntries(input.limit);

                // Map to snake_case for frontend
                return entries.map((e) => ({
                    entry_id: e.id,
                    created_at: e.created_at,
                    raw_text: e.text,
                    attachments_json: e.attachments_json, // Frontend parses this
                    root_id: e.root_id,
                    parent_id: e.parent_id,
                    // Legacy fields if needed
                }));
            }),
    }),

    signals: t.router({
        list: t.procedure
            .input(z.object({
                entry_id: z.string().optional(),
                trigger_capture_id: z.string().optional(),
                include_history: z.boolean().optional().default(false),
                window_days: z.number().optional(),
            }))
            .query(async ({ ctx, input }) => {
                return await ctx.userSignals.getSignals(ctx.userId, input);
            }),
    }),

    commitments: t.router({
        list: t.procedure
            .input(z.object({
                status: z.string().optional(),
                include_history: z.boolean().optional().default(false),
                trigger_capture_id: z.string().optional(),
            }))
            .query(async ({ ctx, input }) => {
                return await ctx.userCommitments.getCommitments(ctx.userId, input);
            }),
    }),

    tasks: t.router({
        list: t.procedure
            .input(z.object({
                status: z.string().optional(),
                include_history: z.boolean().optional().default(false),
                trigger_capture_id: z.string().optional(),
            }))
            .query(async ({ ctx, input }) => {
                return await ctx.userTasks.getTasks(ctx.userId, input);
            }),
    }),

    signalsGenerate: t.procedure
        .input(z.object({
            window_days: z.number().optional().default(30),
            trigger_capture_id: z.string().optional(),
        }))
        .mutation(async ({ ctx, input }) => {
            const triggerId = input.trigger_capture_id || (await ctx.userTimeline.getRecentEntries(1))[0]?.id;
            if (!triggerId) {
                throw new Error('No capture found to trigger generation');
            }
            // Trigger workflow (optional - may not be available in all environments)
            if (ctx.signalsWorkflow) {
                await ctx.signalsWorkflow.create({
                    id: `${ctx.userId}-${triggerId}-${Date.now()}`,
                    params: {
                        userId: ctx.userId,
                        triggerCaptureId: triggerId,
                        windowDays: input.window_days || 30,
                    },
                });
            } else {
                console.warn('Signals workflow not available - skipping workflow trigger');
            }
            return { success: true };
        }),

    feed: t.router({
        getCurrent: t.procedure
            .query(async ({ ctx }) => {
                const response = await ctx.userFeed.fetch(
                    new Request("https://feed/get-current-feed", {
                        method: "POST",
                        body: JSON.stringify({ userId: ctx.userId }),
                    })
                );
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Failed to get feed: ${errorText}`);
                }
                const result = await response.json() as FeedItemRendered[];
                // Ensure we always return an array
                return Array.isArray(result) ? result : [];
            }),
        refresh: t.procedure
            .mutation(async ({ ctx }) => {
                // Trigger feed workflow manually
                if (ctx.feedWorkflow) {
                    await ctx.feedWorkflow.create({
                        id: `${ctx.userId}-feed-manual-${Date.now()}`,
                        params: {
                            userId: ctx.userId,
                        },
                    });
                } else {
                    console.warn('Feed workflow not available - skipping feed refresh');
                }
                return { success: true };
            }),
        getHistory: t.procedure
            .input(z.object({
                limit: z.number().optional().default(10),
            }))
            .query(async ({ ctx, input }) => {
                const response = await ctx.userFeed.fetch(
                    new Request("https://feed/get-feed-history", {
                        method: "POST",
                        body: JSON.stringify({ userId: ctx.userId, limit: input.limit }),
                    })
                );
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Failed to get feed history: ${errorText}`);
                }
                return await response.json();
            }),
    }),
});

export type AppRouter = typeof appRouter;
