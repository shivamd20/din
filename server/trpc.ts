import { initTRPC } from '@trpc/server';
import { z } from 'zod';
import type { UserDO } from './UserDO';
import type { Entry } from './UserDO';
import type { WorkflowParams } from './SignalsWorkflow';
import type { FeedWorkflowParams } from './FeedWorkflow';

export interface Context {
    userId: string;
    userDO: DurableObjectStub<UserDO>;
    signalsWorkflow?: Workflow<WorkflowParams>;
    feedWorkflow?: Workflow<FeedWorkflowParams>;
}

const t = initTRPC.context<Context>().create();

export const appRouter = t.router({
    entries: t.procedure
        .input(z.object({
            text: z.string(),
            source: z.string(),
        }))
        .mutation(async ({ ctx, input }) => {
            const entryId = await ctx.userDO.addEntry(ctx.userId, input.text, input.source);
            return { entry_id: entryId };
        }),

    home: t.procedure
        .query(async ({ ctx }) => {
            return await ctx.userDO.getHome(ctx.userId);
        }),

    // Note: addCommitment removed - commitments are now generated by LLM workflow

    // Legacy/Frontend Compatibility Router
    log: t.router({
        create: t.procedure
            .input(z.object({
                entryId: z.string(),
                text: z.string(),
                attachments: z.array(z.any()).optional(),
                rootId: z.string().optional(),
                parentId: z.string().optional(),
                followUp: z.any().optional(), // Provenance data
            }))
            .mutation(async ({ ctx, input }) => {
                // Map legacy input to addEntry options
                const entryId = await ctx.userDO.addEntry(ctx.userId, input.text, 'client_sync', {
                    id: input.entryId,
                    attachments: input.attachments,
                    rootId: input.rootId,
                    parentId: input.parentId
                });

                // Return empty structure to satisfy legacy UI
                // If we want to restore follow-ups later, we can hook it here.
                return {
                    entry_id: entryId,
                    followUps: [],
                    analysis: null
                };
            }),

        getRecent: t.procedure
            .input(z.object({
                limit: z.number().optional().default(20),
            }))
            .query(async ({ ctx, input }) => {
                // Fetch raw entries
                const entries = await ctx.userDO.getRecentEntries(input.limit) as Entry[];

                // Map to snake_case for frontend
                return entries.map((e: Entry) => ({
                    entry_id: e.id,
                    created_at: e.created_at,
                    raw_text: e.text,
                    attachments_json: e.attachments_json, // Frontend parses this
                    root_id: e.root_id,
                    parent_id: e.parent_id,
                    // Legacy fields if needed
                }));
            }),
    }),

    signals: t.router({
        list: t.procedure
            .input(z.object({
                entry_id: z.string().optional(),
                trigger_capture_id: z.string().optional(),
                include_history: z.boolean().optional().default(false),
                window_days: z.number().optional(),
            }))
            .query(async ({ ctx, input }) => {
                return await ctx.userDO.getSignals(ctx.userId, input);
            }),
    }),

    commitments: t.router({
        list: t.procedure
            .input(z.object({
                status: z.string().optional(),
                include_history: z.boolean().optional().default(false),
                trigger_capture_id: z.string().optional(),
            }))
            .query(async ({ ctx, input }) => {
                return await ctx.userDO.getCommitments(ctx.userId, input);
            }),
    }),

    tasks: t.router({
        list: t.procedure
            .input(z.object({
                status: z.string().optional(),
                include_history: z.boolean().optional().default(false),
                trigger_capture_id: z.string().optional(),
            }))
            .query(async ({ ctx, input }) => {
                return await ctx.userDO.getTasks(ctx.userId, input);
            }),
    }),

    signalsGenerate: t.procedure
        .input(z.object({
            window_days: z.number().optional().default(30),
            trigger_capture_id: z.string().optional(),
        }))
        .mutation(async ({ ctx, input }) => {
            const recentEntries = await ctx.userDO.getRecentEntries(1) as Entry[];
            const triggerId = input.trigger_capture_id || recentEntries[0]?.id;
            if (!triggerId) {
                throw new Error('No capture found to trigger generation');
            }
            // Trigger workflow (optional - may not be available in all environments)
            if (ctx.signalsWorkflow) {
                await ctx.signalsWorkflow.create({
                    id: `${ctx.userId}-${triggerId}-${Date.now()}`,
                    params: {
                        userId: ctx.userId,
                        triggerCaptureId: triggerId,
                        windowDays: input.window_days || 30,
                    },
                });
            } else {
                console.warn('Signals workflow not available - skipping workflow trigger');
            }
            return { success: true };
        }),

    feed: t.router({
        getCurrent: t.procedure
            .query(async ({ ctx }) => {
                // Use direct RPC call instead of fetch()
                const feed = await ctx.userDO.getCurrentFeed(ctx.userId);
                // Ensure we always return an array
                return Array.isArray(feed) ? feed : [];
            }),
        refresh: t.procedure
            .mutation(async ({ ctx }) => {
                // Trigger feed workflow manually
                if (ctx.feedWorkflow) {
                    await ctx.feedWorkflow.create({
                        id: `${ctx.userId}-feed-manual-${Date.now()}`,
                        params: {
                            userId: ctx.userId,
                        },
                    });
                } else {
                    console.warn('Feed workflow not available - skipping feed refresh');
                }
                return { success: true };
            }),
        getHistory: t.procedure
            .input(z.object({
                limit: z.number().optional().default(10),
            }))
            .query(async ({ ctx, input }) => {
                // Use direct RPC call instead of fetch()
                return await ctx.userDO.getFeedHistory(ctx.userId, input.limit);
            }),
    }),
});

export type AppRouter = typeof appRouter;
